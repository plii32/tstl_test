@import halma_pt2 as halma

# Define helper functions for properties
<@
def valid_scores(board):
    return board.blue_score >= 0 and board.red_score >= 0

def valid_player(board):
    return board.current_player in ["blue", "red"]
@>

# Logging
log: POST 1 <halma.Board>.grid
log: POST 1 <halma.Board>.blue_score
log: POST 1 <halma.Board>.red_score
log: POST 1 <halma.Board>.current_player

# State pools
pool: <halma.Board> 1 CONST  # Pool for the game board
pool: <int> 4 CONST  # One pool for both row and column indices

# Properties
property: valid_scores(<halma.Board>)
property: valid_player(<halma.Board>)

# Initialization of the index pool (valid values for row/col indices)
index_pool := <[0..7]>  # Single pool for valid indices

# Initialization of the Board
<halma.Board> := halma.Board(root=None)

# Actions
# Select a piece
~<halma.Board>.selectPiece(index_pool, index_pool) -> \
   <halma.Board>.grid[index_pool][index_pool] is not None \
   and <halma.Board>.grid[index_pool][index_pool][1] == <halma.Board>.current_player

# Move a piece
~<halma.Board>.move(index_pool, index_pool) -> \
   <halma.Board>.current_piece is not None \
   and (index_pool, index_pool) in <halma.Board>.generateMoves(*<halma.Board>.current_piece)

# AI makes a move
<halma.Board>.AI_makeMove()

# Check win conditions
~<halma.Board>.checkWinner()
