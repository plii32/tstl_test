@import halma_pt2 as halma

# Define helper functions for properties
<@
def valid_scores(board):
    return board.blue_score >= 0 and board.red_score >= 0

def valid_player(board):
    return board.current_player in ["blue", "red"]
@>

# Logging
log: POST 1 <halma.Board>.grid
log: POST 1 <halma.Board>.blue_score
log: POST 1 <halma.Board>.red_score
log: POST 1 <halma.Board>.current_player

# State pools
pool: <halma.Board> 1 CONST
pool: <int> 2 CONST  # Declare pool for row
pool: <int> 3 CONST  # Declare pool for col

# Properties
property: valid_scores(<halma.Board>)
property: valid_player(<halma.Board>)

# Initialization
<halma.Board> := halma.Board(root=None)
<int> := <[0..7]>  # Initialize row and col pools with valid indices

# Actions
# Select a piece
~<halma.Board>.selectPiece(<int>, <int>) -> \
   <halma.Board>.grid[<2>][<3>] is not None \
   and <halma.Board>.grid[<2>][<3>][1] == <halma.Board>.current_player

# Move a piece
~<halma.Board>.move(<int>, <int>) -> \
   <halma.Board>.current_piece is not None \
   and (<2>, <3>) in <halma.Board>.generateMoves(*<halma.Board>.current_piece)

# AI makes a move
<halma.Board>.AI_makeMove()

# Check win conditions
~<halma.Board>.checkWinner()
