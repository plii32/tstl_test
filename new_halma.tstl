@import halma_pt1 as halma

# Define Python helper functions for testing
<@
def valid_scores(board):
    """Ensure both players have non-negative scores."""
    return board.blue_score >= 0 and board.red_score >= 0

def valid_player(board):
    """Ensure the current player is valid."""
    return board.current_player in ["blue", "red"]

def valid_game_state(board):
    """Check if the game state is valid."""
    winner = board.checkWinner()
    return winner is None or winner in ["Blue", "Red"]
@>

# Logging -- Monitor key states during testing
log: POST 1 <halma.Board>.grid
log: POST 1 <halma.Board>.blue_score
log: POST 1 <halma.Board>.red_score
log: POST 1 <halma.Board>.current_player

# Define state pools
pool: <int> 4 CONST  # Integer pool for board indices (range [0..7])
pool: <halma.Board> 1 CONST  # Pool for the Halma game board

# Properties to check after each test step
property: valid_scores(<halma.Board>)
property: valid_player(<halma.Board>)
property: valid_game_state(<halma.Board>)

# Initialize the game board
<halma.Board> := halma.Board(root=None)

# Initialize an integer pool for board indices
<int> := <[0..7]>

# Actions: Select a piece
# Guard ensures the piece exists and belongs to the current player
~<halma.Board>.selectPiece(<int>, <int>) -> \
   <halma.Board>.grid[<int>, <int>] is not None and \
   <halma.Board>.grid[<int>, <int>][1] == <halma.Board>.current_player

# Actions: Move a piece
# Guard ensures a piece is selected and the move is valid
~<halma.Board>.move(<int>, <int>) -> \
   <halma.Board>.current_piece is not None and \
   (<int>, <int>) in <halma.Board>.generateMoves(*<halma.Board>.current_piece)

# Check winner (after each step)
<halma.Board>.checkWinner()
